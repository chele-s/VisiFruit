# fruit_diverter_controller.py
"""
Controlador de Desviadores de Frutas con Servomotores SG995
===========================================================

Sistema de clasificaci√≥n autom√°tica que utiliza servomotores SG995 para
desviar frutas etiquetadas hacia cajas espec√≠ficas seg√∫n su categor√≠a.

Flujo de clasificaci√≥n:
- Manzanas ‚Üí Desviador 1 activo ‚Üí Caja manzanas
- Peras ‚Üí Desviador 2 activo ‚Üí Caja peras  
- Limones ‚Üí Sin desviador ‚Üí Caja final (straight through)

Autor: Elias Bautista, Gabriel Calder√≥n, Cristian Hernandez
Fecha: Julio 2025
Versi√≥n: 1.0
"""

import asyncio
import logging
import time
import threading
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Dict, Optional, Any
from pathlib import Path

# GPIO para control de servomotores
try:
    import sys
    from pathlib import Path
    # A√±adir directorio padre al path para importar utils
    parent_dir = Path(__file__).parent.parent
    if str(parent_dir) not in sys.path:
        sys.path.insert(0, str(parent_dir))
    
    from utils.gpio_wrapper import GPIO, GPIO_AVAILABLE, is_simulation_mode
    import pigpio
    PIGPIO_AVAILABLE = True
    
    if is_simulation_mode():
        print("üîß Desviadores: Modo simulaci√≥n activo (ideal para desarrollo)")
    else:
        print("‚úÖ Desviadores: GPIO hardware activo")
        
except ImportError:
    print("‚ö†Ô∏è GPIO/Pigpio no disponible - Modo simulaci√≥n para desviadores")
    GPIO_AVAILABLE = False
    PIGPIO_AVAILABLE = False

logger = logging.getLogger("FruitDiverterController")

class DiverterPosition(Enum):
    """Posiciones del desviador."""
    STRAIGHT = "straight"    # Posici√≥n recta (sin desviar)
    DIVERTED = "diverted"   # Posici√≥n desviada (desviar fruta)

class FruitCategory(Enum):
    """Categor√≠as de frutas para clasificaci√≥n."""
    APPLE = ("apple", 0, "üçé")
    PEAR = ("pear", 1, "üçê") 
    LEMON = ("lemon", 2, "üçã")
    UNKNOWN = ("unknown", 99, "‚ùì")
    
    def __init__(self, name: str, diverter_id: int, emoji: str):
        self.fruit_name = name
        self.diverter_id = diverter_id  # ID del desviador (-1 para sin desviador)
        self.emoji = emoji

@dataclass
class DiverterMetrics:
    """M√©tricas de un desviador."""
    diverter_id: int
    category: FruitCategory
    activations_count: int = 0
    total_runtime_seconds: float = 0.0
    success_rate: float = 100.0
    last_activation: Optional[datetime] = None
    maintenance_score: float = 100.0
    position_errors: int = 0

class ServoMotorSG995:
    """
    Controlador para servomotor SG995.
    
    Caracter√≠sticas SG995:
    - Torque: 8.5 kg-cm
    - Velocidad: 0.2 seg/60¬∞
    - √Ångulo: 180¬∞
    - Frecuencia PWM: 50Hz
    - Ancho pulso: 1-2ms (1ms=0¬∞, 1.5ms=90¬∞, 2ms=180¬∞)
    """
    
    def __init__(self, pin: int, name: str, config: Dict[str, Any]):
        self.pin = pin
        self.name = name
        self.config = config
        
        # Configuraci√≥n SG995
        self.frequency = 50  # Hz
        self.min_pulse_width = 1.0  # ms para 0¬∞
        self.max_pulse_width = 2.0  # ms para 180¬∞
        self.center_pulse_width = 1.5  # ms para 90¬∞
        
        # Posiciones configurables
        self.straight_angle = config.get("straight_angle", 0)    # √Ångulo para posici√≥n recta
        self.diverted_angle = config.get("diverted_angle", 90)   # √Ångulo para desviar
        
        # Estado
        self.current_position = DiverterPosition.STRAIGHT
        self.current_angle = self.straight_angle
        self.is_initialized = False
        self.pwm_instance = None
        self.last_movement_time = 0
        
        # Thread safety
        self._lock = threading.Lock()
        
    async def initialize(self) -> bool:
        """Inicializa el servomotor."""
        try:
            if not GPIO_AVAILABLE:
                logger.warning(f"GPIO no disponible - Servo {self.name} en modo simulaci√≥n")
                self.is_initialized = True
                return True
            
            GPIO.setmode(GPIO.BCM)
            GPIO.setup(self.pin, GPIO.OUT)
            
            # Configurar PWM
            self.pwm_instance = GPIO.PWM(self.pin, self.frequency)
            self.pwm_instance.start(0)
            
            # Mover a posici√≥n inicial (recta)
            await self.move_to_position(DiverterPosition.STRAIGHT)
            
            self.is_initialized = True
            logger.info(f"Servo {self.name} (Pin {self.pin}) inicializado correctamente")
            return True
            
        except Exception as e:
            logger.error(f"Error inicializando servo {self.name}: {e}")
            return False
    
    def _angle_to_duty_cycle(self, angle: float) -> float:
        """Convierte √°ngulo a duty cycle para PWM."""
        # Limitar √°ngulo
        angle = max(0, min(180, angle))
        
        # Calcular ancho de pulso en ms
        pulse_width = self.min_pulse_width + (angle / 180.0) * (self.max_pulse_width - self.min_pulse_width)
        
        # Convertir a duty cycle (per√≠odo = 20ms a 50Hz)
        duty_cycle = (pulse_width / 20.0) * 100
        return duty_cycle
    
    async def move_to_angle(self, target_angle: float) -> bool:
        """Mueve el servo a un √°ngulo espec√≠fico."""
        try:
            with self._lock:
                if not self.is_initialized:
                    return False
                
                # Limitar √°ngulo
                target_angle = max(0, min(180, target_angle))
                
                if GPIO_AVAILABLE and self.pwm_instance:
                    # Movimiento real
                    duty_cycle = self._angle_to_duty_cycle(target_angle)
                    self.pwm_instance.ChangeDutyCycle(duty_cycle)
                    
                    # Calcular tiempo de movimiento (aprox 0.2s por 60¬∞)
                    angle_diff = abs(target_angle - self.current_angle)
                    movement_time = (angle_diff / 60.0) * 0.2
                    
                    # Esperar movimiento
                    await asyncio.sleep(movement_time + 0.1)  # +100ms margen
                    
                    # Apagar PWM para evitar ruido
                    self.pwm_instance.ChangeDutyCycle(0)
                else:
                    # Simulaci√≥n
                    await asyncio.sleep(0.3)
                
                self.current_angle = target_angle
                self.last_movement_time = time.time()
                
                logger.debug(f"Servo {self.name} movido a {target_angle}¬∞")
                return True
                
        except Exception as e:
            logger.error(f"Error moviendo servo {self.name} a {target_angle}¬∞: {e}")
            return False
    
    async def move_to_position(self, position: DiverterPosition) -> bool:
        """Mueve el servo a una posici√≥n predefinida."""
        target_angle = self.straight_angle if position == DiverterPosition.STRAIGHT else self.diverted_angle
        
        success = await self.move_to_angle(target_angle)
        if success:
            self.current_position = position
            logger.info(f"Servo {self.name} en posici√≥n {position.value} ({target_angle}¬∞)")
        
        return success
    
    def get_status(self) -> Dict[str, Any]:
        """Obtiene el estado del servo."""
        return {
            "name": self.name,
            "pin": self.pin,
            "initialized": self.is_initialized,
            "current_position": self.current_position.value,
            "current_angle": self.current_angle,
            "last_movement": self.last_movement_time,
            "config": {
                "straight_angle": self.straight_angle,
                "diverted_angle": self.diverted_angle
            }
        }
    
    async def cleanup(self):
        """Limpia recursos del servo."""
        try:
            with self._lock:
                if GPIO_AVAILABLE and self.pwm_instance:
                    self.pwm_instance.stop()
                    GPIO.cleanup(self.pin)
                
                self.is_initialized = False
                logger.info(f"Servo {self.name} limpiado correctamente")
                
        except Exception as e:
            logger.error(f"Error limpiando servo {self.name}: {e}")

class FruitDiverterController:
    """
    Controlador principal del sistema de desviadores de frutas.
    
    Gestiona m√∫ltiples servomotores SG995 para clasificar frutas:
    - Desviador 0: Manzanas ‚Üí Caja manzanas
    - Desviador 1: Peras ‚Üí Caja peras
    - Sin desviador: Limones ‚Üí Caja final
    """
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.diverters: Dict[int, ServoMotorSG995] = {}
        self.diverter_metrics: Dict[int, DiverterMetrics] = {}
        
        # Configuraci√≥n de timing
        self.activation_duration = config.get("activation_duration_seconds", 2.0)
        self.return_delay = config.get("return_delay_seconds", 0.5)
        
        # Estado del sistema
        self.is_initialized = False
        self.active_diverters = set()
        
        # Thread safety
        self._lock = threading.RLock()
        
        logger.info("Controlador de desviadores inicializado")
    
    async def initialize(self) -> bool:
        """Inicializa todos los desviadores."""
        try:
            logger.info("Inicializando sistema de desviadores...")
            
            diverters_config = self.config.get("diverters", {})
            
            # Configuraci√≥n por defecto para 2 desviadores
            default_diverters = {
                0: {  # Desviador para manzanas
                    "pin": 18,
                    "name": "Diverter-Apple",
                    "category": "apple",
                    "straight_angle": 0,
                    "diverted_angle": 90,
                    "description": "Desviador para manzanas hacia caja espec√≠fica"
                },
                1: {  # Desviador para peras
                    "pin": 19,
                    "name": "Diverter-Pear", 
                    "category": "pear",
                    "straight_angle": 0,
                    "diverted_angle": 90,
                    "description": "Desviador para peras hacia caja espec√≠fica"
                }
                # Limones no tienen desviador - van directo a caja final
            }
            
            # Usar configuraci√≥n personalizada si est√° disponible, sino usar por defecto
            diverters_to_create = diverters_config if diverters_config else default_diverters
            
            # Inicializar cada desviador
            for diverter_id, diverter_config in diverters_to_create.items():
                servo = ServoMotorSG995(
                    pin=diverter_config["pin"],
                    name=diverter_config["name"],
                    config=diverter_config
                )
                
                if await servo.initialize():
                    self.diverters[int(diverter_id)] = servo
                    
                    # Inicializar m√©tricas
                    try:
                        category = FruitCategory[diverter_config["category"].upper()]
                    except KeyError:
                        category = FruitCategory.UNKNOWN
                    
                    self.diverter_metrics[int(diverter_id)] = DiverterMetrics(
                        diverter_id=int(diverter_id),
                        category=category
                    )
                    
                    logger.info(f"‚úÖ Desviador {diverter_id} ({diverter_config['name']}) inicializado")
                else:
                    logger.error(f"‚ùå Fallo inicializando desviador {diverter_id}")
            
            self.is_initialized = len(self.diverters) > 0
            
            if self.is_initialized:
                logger.info(f"üöÄ Sistema de desviadores inicializado: {len(self.diverters)} desviadores operativos")
                logger.info("üìã Configuraci√≥n:")
                logger.info("   üçé Manzanas ‚Üí Desviador 0 ‚Üí Caja manzanas")
                logger.info("   üçê Peras ‚Üí Desviador 1 ‚Üí Caja peras")
                logger.info("   üçã Limones ‚Üí Sin desviador ‚Üí Caja final")
            else:
                logger.warning("‚ö†Ô∏è Sin desviadores operativos - Modo pass-through")
            
            return self.is_initialized
            
        except Exception as e:
            logger.error(f"Error inicializando desviadores: {e}")
            return False
    
    async def classify_fruit(self, category: FruitCategory, delay_seconds: float = 0.0) -> bool:
        """
        Clasifica una fruta activando el desviador correspondiente.
        
        Args:
            category: Categor√≠a de la fruta detectada
            delay_seconds: Tiempo de espera antes de activar (para sincronizaci√≥n con banda)
        """
        try:
            if not self.is_initialized:
                logger.warning("Sistema de desviadores no inicializado")
                return False
            
            # Esperar delay si es necesario
            if delay_seconds > 0:
                logger.info(f"‚è±Ô∏è Esperando {delay_seconds:.1f}s para clasificar {category.emoji}")
                await asyncio.sleep(delay_seconds)
            
            # Determinar acci√≥n seg√∫n categor√≠a
            if category == FruitCategory.APPLE:
                return await self._activate_diverter(0, "manzanas")
            elif category == FruitCategory.PEAR:
                return await self._activate_diverter(1, "peras")
            elif category == FruitCategory.LEMON:
                # Limones van directo - no activar desviador
                logger.info("üçã Lim√≥n: pass-through a caja final")
                return True
            else:
                logger.warning(f"‚ùì Categor√≠a desconocida: {category.fruit_name} - pass-through")
                return True
                
        except Exception as e:
            logger.error(f"Error clasificando fruta {category.emoji}: {e}")
            return False
    
    async def _activate_diverter(self, diverter_id: int, fruit_name: str) -> bool:
        """Activa un desviador espec√≠fico."""
        try:
            if diverter_id not in self.diverters:
                logger.error(f"Desviador {diverter_id} no existe")
                return False
            
            with self._lock:
                if diverter_id in self.active_diverters:
                    logger.warning(f"Desviador {diverter_id} ya est√° activo")
                    return False
                
                self.active_diverters.add(diverter_id)
            
            diverter = self.diverters[diverter_id]
            metrics = self.diverter_metrics[diverter_id]
            
            start_time = time.time()
            
            logger.info(f"üîÑ Activando desviador {diverter_id} para {fruit_name}")
            
            # 1. Mover a posici√≥n desviada
            success = await diverter.move_to_position(DiverterPosition.DIVERTED)
            if not success:
                with self._lock:
                    self.active_diverters.discard(diverter_id)
                return False
            
            # 2. Mantener posici√≥n durante tiempo de activaci√≥n
            await asyncio.sleep(self.activation_duration)
            
            # 3. Regresar a posici√≥n recta
            success = await diverter.move_to_position(DiverterPosition.STRAIGHT)
            
            # 4. Actualizar m√©tricas
            runtime = time.time() - start_time
            metrics.activations_count += 1
            metrics.total_runtime_seconds += runtime
            metrics.last_activation = datetime.now()
            
            if not success:
                metrics.position_errors += 1
                metrics.success_rate = max(0, metrics.success_rate - 1)
            
            with self._lock:
                self.active_diverters.discard(diverter_id)
            
            logger.info(f"‚úÖ Desviador {diverter_id} completado - {fruit_name} clasificadas")
            return success
            
        except Exception as e:
            logger.error(f"Error activando desviador {diverter_id}: {e}")
            with self._lock:
                self.active_diverters.discard(diverter_id)
            return False
    
    async def emergency_stop(self):
        """Parada de emergencia - mueve todos los desviadores a posici√≥n recta."""
        logger.critical("üö® PARADA DE EMERGENCIA - Desviadores a posici√≥n segura")
        
        tasks = []
        for diverter in self.diverters.values():
            task = asyncio.create_task(diverter.move_to_position(DiverterPosition.STRAIGHT))
            tasks.append(task)
        
        if tasks:
            await asyncio.gather(*tasks, return_exceptions=True)
        
        with self._lock:
            self.active_diverters.clear()
        
        logger.info("üõ°Ô∏è Todos los desviadores en posici√≥n segura")
    
    def get_status(self) -> Dict[str, Any]:
        """Obtiene el estado completo del sistema de desviadores."""
        return {
            "initialized": self.is_initialized,
            "total_diverters": len(self.diverters),
            "active_diverters": list(self.active_diverters),
            "diverters": {
                diverter_id: diverter.get_status()
                for diverter_id, diverter in self.diverters.items()
            },
            "metrics": {
                diverter_id: {
                    "category": metrics.category.fruit_name,
                    "emoji": metrics.category.emoji,
                    "activations": metrics.activations_count,
                    "runtime_seconds": metrics.total_runtime_seconds,
                    "success_rate": metrics.success_rate,
                    "last_activation": metrics.last_activation.isoformat() if metrics.last_activation else None,
                    "position_errors": metrics.position_errors
                }
                for diverter_id, metrics in self.diverter_metrics.items()
            },
            "configuration": {
                "activation_duration": self.activation_duration,
                "return_delay": self.return_delay
            }
        }
    
    async def calibrate_all(self) -> bool:
        """Calibra todos los desviadores moviendo a posiciones extremas."""
        logger.info("üîß Iniciando calibraci√≥n de desviadores...")
        
        try:
            for diverter_id, diverter in self.diverters.items():
                logger.info(f"Calibrando desviador {diverter_id}...")
                
                # Mover a posici√≥n recta
                await diverter.move_to_position(DiverterPosition.STRAIGHT)
                await asyncio.sleep(1)
                
                # Mover a posici√≥n desviada
                await diverter.move_to_position(DiverterPosition.DIVERTED)
                await asyncio.sleep(1)
                
                # Regresar a posici√≥n recta
                await diverter.move_to_position(DiverterPosition.STRAIGHT)
                
                logger.info(f"‚úÖ Desviador {diverter_id} calibrado")
            
            logger.info("üéâ Calibraci√≥n de desviadores completada")
            return True
            
        except Exception as e:
            logger.error(f"Error en calibraci√≥n de desviadores: {e}")
            return False
    
    async def cleanup(self):
        """Limpia todos los recursos de los desviadores."""
        logger.info("Limpiando sistema de desviadores...")
        
        try:
            # Parar cualquier activaci√≥n en curso
            await self.emergency_stop()
            
            # Limpiar cada desviador
            for diverter in self.diverters.values():
                await diverter.cleanup()
            
            self.diverters.clear()
            self.diverter_metrics.clear()
            self.is_initialized = False
            
            logger.info("üßπ Sistema de desviadores limpiado correctamente")
            
        except Exception as e:
            logger.error(f"Error limpiando desviadores: {e}")
